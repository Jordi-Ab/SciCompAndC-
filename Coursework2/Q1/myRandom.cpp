#include <string>
#include <stdlib.h>
#include <cmath>

double** _allocateMatrixMemory(int n_rows, int n_cols);
void _freeMatrixMemory(int n_rows, double** matrix);

static void initRandomSeed() {
    static bool initialized = false;
    if (!initialized) {
        srand(int(time(NULL)));
        initialized = true;
    }
}

int randomInteger(int low, int high) {
    initRandomSeed();
    double d = rand() / (double(RAND_MAX) + 1);
    double s = d * (double(high) - low + 1);
    return int(floor(low + s));
}

double randomReal(double low, double high) {
    initRandomSeed();
    double d = rand() / (double(RAND_MAX) + 1);
    double s = d * (high - low);
    return low + s;
}

double** createRandomMatrix(int n_rows, int n_cols, bool integer=true){
	double** rand_matrix = _allocateMatrixMemory(n_rows,n_cols);
	for (int i=0; i<n_rows; i++){
		for (int j=0; j<n_cols; j++){
			if(integer){ // Matrix with random integer entries
				int entry = randomInteger(-9, 9);
				rand_matrix[i][j] = (double)entry;
			} else { // Matrix with random double precision entries
				double entry = randomReal(-9.9, 9.9);
				rand_matrix[i][j] = entry;
			}
		}
	}
	return rand_matrix;
}

double* createRandomVector(int size, bool integer=true){
	double* rand_vec;
	rand_vec = new double[size];
	for (int i=0; i<size; i++){
		if (integer){ // For random vectors of integers
			int entry = randomInteger(-9, 9);
			rand_vec[i] = (double)entry;
		}else{ // For random vectors of double precision
			double entry = randomReal(-9.9, 9.9); 
			rand_vec[i] = entry; 
		}
	}
	return rand_vec;
}



int myRandomInteger(){
    /*
     I created this function because the conventional way of
     creating random Integers, which is in the randomInteger
     function, is biased towards the lowest value of the range.
     When you run the program, the first generated number is
     almost always the lowest value on the range. 
     In this program the first time I called randomInteger 
     was to decide the size of the vectors, so almost
     always it returned a 2x1 vector.
     So I hacked a function that the first time you run it returns
     a truly random Integer between 2 and 9.
     
     #Its not the most efficient way of creating a non biased 
     random Integer between an interval, but does the job 
     for testing purposes.
    */
    initRandomSeed();
    int r = rand();
    std::string str = std::to_string(r);
    char last_value = str[str.length()-1];
    int l = last_value - 48;
    
    if (l <= 1) l+=2;
    
    return l;
    /*
     Basically, it chooses the last integer in the number generated by
     rand(). The problem of the bias towards the lowest value of the 
     interval is that rand() returns very large numbers, so the first
     numbers of rand() almost never change, so when doing all the
     manipulations to map the rand() to an integer on an interval, it
     almost always returned the lowest value. So instead of that I worked
     with the last integer of rand(), which do varies very much every time
     you run it for the first time.
    */
}

//*----------Internal Methods--------*//

/*
Function: allocateMatrixMemory
Usage: double** a_matrix = allocateMatrixMemory(2, 3)
---------------------------------------------
Saves space in the computer's memory to hold a
matrix of n_rows by n_cols size.
*/
double** _allocateMatrixMemory(int n_rows, int n_cols){
	double** matrix;
	matrix = new double* [n_rows];
	for (int i=0; i<n_rows; i++){
		matrix[i] = new double [n_cols];
	}
	return matrix;
}

/*
Function: freeMatrixMemory
Usage: freeMatrixMemory(2, a_matrix)
--------------------------------------------------
Receives the number of rows of the matrix, and the
matrix itself for which you want to free the memory space. 
Deallocates the memory used by the given matrix.
*/
void _freeMatrixMemory(int n_rows, double** matrix){
	for (int i=0; i<n_rows; i++) {
		delete[] matrix[i];
	}
	delete[] matrix;
}
